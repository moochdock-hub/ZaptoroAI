name: Deploy to Hostinger

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Deploy to Hostinger via SFTP (key auth)
        env:
          DEFAULT_PORT: '22'
          HOSTINGER_PORT: ${{ secrets.HOSTINGER_PORT }}
        run: |
          sudo apt-get update && sudo apt-get install -y lftp openssh-client
          mkdir -p ~/.ssh
          # Write the private key reliably and normalize line endings (handles Windows CRLF in secret)
          printf '%s\n' "${{ secrets.HOSTINGER_SSH_KEY }}" > ~/.ssh/id_rsa
          # Remove any CRLF that might have been introduced when copying the key into GitHub Secrets
          sed -i 's/\r$//' ~/.ssh/id_rsa || true
          chmod 600 ~/.ssh/id_rsa
          # Quick validation: ensure the secret contains a private key and is usable
          if ! grep -q "PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "ERROR: the provided HOSTINGER_SSH_KEY does not look like a private key (missing 'PRIVATE KEY' header)."
            echo "Possible causes: you pasted the public key instead of the private key, or the secret was truncated."
            echo "Please set the repository secret 'HOSTINGER_SSH_KEY' to the full private key PEM/OPENSSH block."
            exit 1
          fi
          # Try to derive the public key from the private key (fails if key is passphrase-protected or malformed)
          if ! ssh-keygen -y -f ~/.ssh/id_rsa > /tmp/id_rsa.pub 2>/dev/null; then
            echo "ERROR: unable to extract public key from the provided private key. The key may be encrypted with a passphrase or malformed."
            echo "GitHub Actions cannot provide an interactive passphrase. Create a new key without a passphrase for CI or upload an unencrypted private key."
            exit 1
          fi
          # Print a short fingerprint to help you confirm the correct key is uploaded to Hostinger (no private key contents shown)
          echo "Derived public key fingerprint (compare this with Hostinger):"
          ssh-keygen -lf /tmp/id_rsa.pub || true
          # Parse host and optional port robustly (accepts host, host:port, sftp://host, user@host, etc.)
          RAW_HOST="${{ secrets.hostinger_host }}"
          echo "Raw host (masked): $RAW_HOST"
          # Trim whitespace
          HOST=$(echo "$RAW_HOST" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          # Remove URI scheme like sftp:// or ssh://
          HOST=$(echo "$HOST" | sed -E 's#^[a-zA-Z][a-zA-Z0-9+.-]*://##')
          # Remove username@ if present
          HOST=$(echo "$HOST" | awk -F'@' '{print $NF}')
          # Remove any path or trailing slash
          HOST=$(echo "$HOST" | cut -d'/' -f1)
          # default port
          PORT="$DEFAULT_PORT"
          # If host contains colon it's host:port (IPv6 with [] is supported by later parsing)
          if echo "$HOST" | grep -qE '^[^:]+:[0-9]+$'; then
            # simple host:port
            PORT="$(echo "$HOST" | cut -d: -f2-)"
            HOST="$(echo "$HOST" | cut -d: -f1)"
          elif [ -n "$HOSTINGER_PORT" ]; then
            PORT="$HOSTINGER_PORT"
          fi
          # Final trim
          HOST=$(echo "$HOST" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          # Validate host looks like an IP or hostname (basic check)
          if ! echo "$HOST" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$|^[a-zA-Z0-9.-]+$|^\[[0-9a-fA-F:]+\]$'; then
            echo "Parsed host contains invalid characters: '$HOST'"
            echo "Please set the repository secret 'hostinger_host' to just the hostname or IP (optionally as host:port). Current raw (masked) value: $RAW_HOST"
            exit 1
          fi
          echo "Using SFTP host: $HOST and port: $PORT"
          # Add host to known_hosts to avoid prompt (use -p only when port is numeric)
          ssh-keyscan -p "$PORT" "$HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          # Quick SSH connectivity test
          echo "Testing SSH connectivity..."
          ssh -i ~/.ssh/id_rsa -p "$PORT" -o BatchMode=yes -o StrictHostKeyChecking=no "${{ secrets.HOSTINGER_USER }}@$HOST" "echo SSH_OK" || { echo "SSH connectivity failed"; exit 1; }

          # Deploy by streaming a tarball over SSH and extracting on the remote host (avoids lftp quoting issues)
          echo "Streaming tarball to remote and extracting to /home/u291229706/domains/zaptoroai.com/public_html/"
          tar -czf - --exclude .git --exclude .github --exclude node_modules --exclude .vscode . | ssh -i ~/.ssh/id_rsa -p "$PORT" -o StrictHostKeyChecking=no "${{ secrets.HOSTINGER_USER }}@$HOST" "mkdir -p /home/u291229706/domains/zaptoroai.com/public_html/ && tar -xzf - -C /home/u291229706/domains/zaptoroai.com/public_html/"

      - name: Verify deployed file checksum
        run: |
          echo "Downloading deployed HTML and computing sha256..."
          sudo apt-get install -y curl coreutils
          curl -sS https://zaptoroai.com/ZAPTOROAI.html -o /tmp/deployed.html || true
          sha_deployed=$(sha256sum /tmp/deployed.html 2>/dev/null | awk '{print $1}' || echo "")
          sha_local=$(sha256sum ZAPTOROAI.html | awk '{print $1}')
          echo "deployed: $sha_deployed"
          echo "local:    $sha_local"
          if [ "$sha_deployed" = "$sha_local" ]; then echo "CHECKSUM MATCH: deployed file matches repo"; else echo "CHECKSUM MISMATCH: deployed file does NOT match repo"; exit 1; fi